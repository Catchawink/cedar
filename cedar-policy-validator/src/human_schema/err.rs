/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

use std::iter::{Chain, Once};
use std::vec;
use std::{
    collections::{HashMap, HashSet},
    fmt::Display,
};

use cedar_policy_core::parser::{
    err::{expected_to_string, ExpectedTokenConfig},
    unescape::UnescapeError,
    Loc, Node,
};
use lalrpop_util as lalr;
use lazy_static::lazy_static;
use miette::{Diagnostic, LabeledSpan, SourceSpan};
use nonempty::NonEmpty;
use smol_str::SmolStr;
use thiserror::Error;

use super::ast::PR;

#[derive(Debug, Clone, PartialEq, Eq, Error)]
pub enum UserError {
    #[error("An empty list was passed")]
    EmptyList,
    #[error("Invalid escape codes")]
    StringEscape(NonEmpty<UnescapeError>),
    #[error("`{0}` is a reserved identifier")]
    ReservedIdentifierUsed(SmolStr),
}

pub(crate) type RawLocation = usize;
pub(crate) type RawToken<'a> = lalr::lexer::Token<'a>;
pub(crate) type RawUserError = Node<UserError>;

pub(crate) type RawParseError<'a> = lalr::ParseError<RawLocation, RawToken<'a>, RawUserError>;
pub(crate) type RawErrorRecovery<'a> = lalr::ErrorRecovery<RawLocation, RawToken<'a>, RawUserError>;

type OwnedRawParseError = lalr::ParseError<RawLocation, String, RawUserError>;

lazy_static! {
    static ref SCHEMA_TOKEN_CONFIG: ExpectedTokenConfig = ExpectedTokenConfig {
        friendly_token_names: HashMap::from([
            ("IN", "`in`"),
            ("PRINCIPAL", "`principal`"),
            ("ACTION", "`action`"),
            ("RESOURCE", "`resource`"),
            ("CONTEXT", "`context`"),
            ("STRINGLIT", "string literal"),
            ("ENTITY", "`entity`"),
            ("NAMESPACE", "`namespace`"),
            ("TYPE", "`type`"),
            ("SET", "`Set`"),
            ("IDENTIFIER", "identifier"),
        ]),
        impossible_tokens: HashSet::new(),
        special_identifier_tokens: HashSet::from([
            "NAMESPACE",
            "ENTITY",
            "IN",
            "TYPE",
            "APPLIESTO",
            "PRINCIPAL",
            "ACTION",
            "RESOURCE",
            "CONTEXT",
            "ATTRIBUTES",
            "LONG",
            "STRING",
            "BOOL",
        ]),
        identifier_sentinel: "IDENTIFIER",
        first_set_identifier_tokens: HashSet::from(["SET"]),
        first_set_sentinel: "\"{\"",
    };
}

/// For errors during parsing
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ParseError {
    /// Error generated by lalrpop
    err: OwnedRawParseError,
}

impl From<RawParseError<'_>> for ParseError {
    fn from(err: RawParseError<'_>) -> Self {
        Self {
            err: err.map_token(|token| token.to_string()),
        }
    }
}

impl From<RawErrorRecovery<'_>> for ParseError {
    fn from(recovery: RawErrorRecovery<'_>) -> Self {
        recovery.error.into()
    }
}

impl ParseError {
    /// Extract a primary source span locating the error.
    pub fn primary_source_span(&self) -> SourceSpan {
        let Self { err } = self;
        match err {
            OwnedRawParseError::InvalidToken { location } => SourceSpan::from(*location),
            OwnedRawParseError::UnrecognizedEof { location, .. } => SourceSpan::from(*location),
            OwnedRawParseError::UnrecognizedToken {
                token: (token_start, _, token_end),
                ..
            } => SourceSpan::from(*token_start..*token_end),
            OwnedRawParseError::ExtraToken {
                token: (token_start, _, token_end),
            } => SourceSpan::from(*token_start..*token_end),
            OwnedRawParseError::User { error } => error.loc.span,
        }
    }
}

impl Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let Self { err } = self;
        match err {
            OwnedRawParseError::InvalidToken { .. } => write!(f, "invalid token"),
            OwnedRawParseError::UnrecognizedEof { .. } => write!(f, "unexpected end of input"),
            OwnedRawParseError::UnrecognizedToken {
                token: (_, token, _),
                ..
            } => write!(f, "unexpected token `{token}`"),
            OwnedRawParseError::ExtraToken {
                token: (_, token, _),
                ..
            } => write!(f, "extra token `{token}`"),
            OwnedRawParseError::User {
                error: Node { node, .. },
            } => write!(f, "{node}"),
        }
    }
}

impl std::error::Error for ParseError {}

impl Diagnostic for ParseError {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        let primary_source_span = self.primary_source_span();
        let Self { err } = self;
        let labeled_span = match err {
            OwnedRawParseError::InvalidToken { .. } => LabeledSpan::underline(primary_source_span),
            OwnedRawParseError::UnrecognizedEof { expected, .. } => LabeledSpan::new_with_span(
                expected_to_string(expected, &SCHEMA_TOKEN_CONFIG),
                primary_source_span,
            ),
            OwnedRawParseError::UnrecognizedToken { expected, .. } => LabeledSpan::new_with_span(
                expected_to_string(expected, &SCHEMA_TOKEN_CONFIG),
                primary_source_span,
            ),
            OwnedRawParseError::ExtraToken { .. } => LabeledSpan::underline(primary_source_span),
            OwnedRawParseError::User { .. } => LabeledSpan::underline(primary_source_span),
        };
        Some(Box::new(std::iter::once(labeled_span)))
    }
}

/// Multiple parse errors.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ParseErrors(Box<NonEmpty<ParseError>>);

impl ParseErrors {
    /// Creates a new [`ParseErrors`] ensuring it contains at least one error by construction
    pub fn new(first: ParseError, rest: impl IntoIterator<Item = ParseError>) -> Self {
        let mut nv = NonEmpty::singleton(first);
        let mut v = rest.into_iter().collect::<Vec<_>>();
        nv.append(&mut v);
        Self(Box::new(nv))
    }

    /// Attempt to create a [`ParseErrors`] from an iterator over [`ParseError`]s.
    /// Returns [`None`] if the iterator is empty
    pub fn try_from_iter(i: impl IntoIterator<Item = ParseError>) -> Option<Self> {
        let v = i.into_iter().collect::<Vec<_>>();
        Some(Self(Box::new(NonEmpty::from_vec(v)?)))
    }

    /// (Borrowed) Iterator over reported parse errors
    pub fn iter(&self) -> impl Iterator<Item = &ParseError> {
        self.0.iter()
    }
}

impl IntoIterator for ParseErrors {
    type Item = ParseError;
    type IntoIter = Chain<Once<ParseError>, vec::IntoIter<ParseError>>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl Display for ParseErrors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0.first())
    }
}

impl std::error::Error for ParseErrors {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        std::error::Error::source(self.0.first())
    }
}

// Except for `.related()`, everything else is forwarded to the first error, if it is present.
// This ensures that users who only use `Display`, `.code()`, `.labels()` etc, still get rich
// information for the first error, even if they don't realize there are multiple errors here.
// See cedar-policy/cedar#326.
impl Diagnostic for ParseErrors {
    fn related<'a>(&'a self) -> Option<Box<dyn Iterator<Item = &'a dyn Diagnostic> + 'a>> {
        // the .related() on the first error, and then the 2nd through Nth errors (but not their own .related())
        let mut errs = self.iter().map(|err| err as &dyn Diagnostic);
        errs.next().map(move |first_err| match first_err.related() {
            Some(first_err_related) => Box::new(first_err_related.chain(errs)),
            None => Box::new(errs) as Box<dyn Iterator<Item = _>>,
        })
    }

    fn code<'a>(&'a self) -> Option<Box<dyn Display + 'a>> {
        Diagnostic::code(self.0.first())
    }

    fn severity(&self) -> Option<miette::Severity> {
        Diagnostic::severity(self.0.first())
    }

    fn help<'a>(&'a self) -> Option<Box<dyn Display + 'a>> {
        Diagnostic::help(self.0.first())
    }

    fn url<'a>(&'a self) -> Option<Box<dyn Display + 'a>> {
        Diagnostic::url(self.0.first())
    }

    fn source_code(&self) -> Option<&dyn miette::SourceCode> {
        Diagnostic::source_code(self.0.first())
    }

    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        Diagnostic::labels(self.0.first())
    }

    fn diagnostic_source(&self) -> Option<&dyn Diagnostic> {
        Diagnostic::diagnostic_source(self.0.first())
    }
}

/// Collection of [`ToJsonSchemaError`]
// This struct is publicly exposed
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ToJsonSchemaErrors(NonEmpty<ToJsonSchemaError>);

impl ToJsonSchemaErrors {
    /// Constructor
    pub fn new(errs: NonEmpty<ToJsonSchemaError>) -> Self {
        Self(errs)
    }

    /// (Borrowed) iterator over the errors
    pub fn iter(&self) -> impl Iterator<Item = &ToJsonSchemaError> {
        self.0.iter()
    }
}

impl IntoIterator for ToJsonSchemaErrors {
    type Item = ToJsonSchemaError;
    type IntoIter = <NonEmpty<ToJsonSchemaError> as IntoIterator>::IntoIter;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl From<ToJsonSchemaError> for ToJsonSchemaErrors {
    fn from(value: ToJsonSchemaError) -> Self {
        Self(NonEmpty::singleton(value))
    }
}

impl Display for ToJsonSchemaErrors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0.first()) // intentionally showing only the first error; see #326 for discussion on a similar error type
    }
}

impl std::error::Error for ToJsonSchemaErrors {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        self.0.first().source()
    }

    #[allow(deprecated)]
    fn description(&self) -> &str {
        self.0.first().description()
    }

    #[allow(deprecated)]
    fn cause(&self) -> Option<&dyn std::error::Error> {
        self.0.first().cause()
    }
}

// Except for `.related()`, everything else is forwarded to the first error, if it is present.
// This ensures that users who only use `Display`, `.code()`, `.labels()` etc, still get rich
// information for the first error, even if they don't realize there are multiple errors here.
// See #326 for discussion on a similar error type.
impl Diagnostic for ToJsonSchemaErrors {
    fn related<'a>(&'a self) -> Option<Box<dyn Iterator<Item = &'a dyn Diagnostic> + 'a>> {
        // the .related() on the first error, and then the 2nd through Nth errors (but not their own .related())
        let mut errs = self.iter().map(|err| err as &dyn Diagnostic);
        errs.next().map(move |first_err| match first_err.related() {
            Some(first_err_related) => Box::new(first_err_related.chain(errs)),
            None => Box::new(errs) as Box<dyn Iterator<Item = _>>,
        })
    }

    fn code<'a>(&'a self) -> Option<Box<dyn Display + 'a>> {
        self.0.first().code()
    }

    fn severity(&self) -> Option<miette::Severity> {
        self.0.first().severity()
    }

    fn help<'a>(&'a self) -> Option<Box<dyn Display + 'a>> {
        self.0.first().help()
    }

    fn url<'a>(&'a self) -> Option<Box<dyn Display + 'a>> {
        self.0.first().url()
    }

    fn source_code(&self) -> Option<&dyn miette::SourceCode> {
        self.0.first().source_code()
    }

    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        self.0.first().labels()
    }

    fn diagnostic_source(&self) -> Option<&dyn Diagnostic> {
        self.0.first().diagnostic_source()
    }
}

/// For errors during schema format conversion
// This enum is publicly exposed
#[derive(Clone, Debug, Error, PartialEq, Eq, Diagnostic)]
pub enum ToJsonSchemaError {
    /// Error raised when there are duplicate keys
    #[error(transparent)]
    #[diagnostic(transparent)]
    DuplicateKeys(#[from] DuplicateKeys),
    /// Error raised when there are duplicate declarations
    #[error(transparent)]
    #[diagnostic(transparent)]
    DuplicateDeclarations(#[from] DuplicateDeclarations),
    /// Error raised when there are duplicate context declarations
    #[error(transparent)]
    #[diagnostic(transparent)]
    DuplicateContext(DuplicateContext),
    /// Error raised when there are duplicate `principal` or `resource` declarations
    #[error(transparent)]
    #[diagnostic(transparent)]
    DuplicatePrincipalOrResource(#[from] DuplicatePrincipalOrResource),
    /// Error raised when there are duplicate `principal` or `resource` declarations
    #[error(transparent)]
    #[diagnostic(transparent)]
    NoPrincipalOrResource(#[from] NoPrincipalOrResource),

    /// Error raised when there are duplicate namespace IDs
    #[error(transparent)]
    #[diagnostic(transparent)]
    DuplicateNameSpaces(#[from] DuplicateNameSpaces),
    /// Error raised when a type is used without being defined
    #[error(transparent)]
    #[diagnostic(transparent)]
    UnknownTypeName(#[from] UnknownTypeName),
    /// Use of a reserved namespace
    #[error(transparent)]
    #[diagnostic(transparent)]
    UseReservedNamespace(#[from] UseReservedNamespace),
}

/// Error raised when there are duplicate keys
#[derive(Debug, Error, Clone, PartialEq, Eq)]
#[error("duplicate keys: {key}")]
pub struct DuplicateKeys {
    key: SmolStr,
    loc1: Loc,
    loc2: Loc,
}

impl DuplicateKeys {
    /// The duplicated key
    pub fn key(&'_ self) -> impl AsRef<str> + '_ {
        self.key.as_ref()
    }
}

impl Diagnostic for DuplicateKeys {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        let l1 = LabeledSpan::underline(self.loc1.span);
        let l2 = LabeledSpan::underline(self.loc2.span);
        Some(Box::new(vec![l1, l2].into_iter()))
    }
}

/// Error raised when there are duplicate declarations
#[derive(Debug, Clone, Error, Eq, PartialEq)]
#[error("duplicate declarations: {decl}")]
pub struct DuplicateDeclarations {
    decl: SmolStr,
    loc1: Loc,
    loc2: Loc,
}

impl DuplicateDeclarations {
    /// Name of the declaration that was duplicated
    pub fn decl(&'_ self) -> impl AsRef<str> + '_ {
        self.decl.as_ref()
    }
}

impl Diagnostic for DuplicateDeclarations {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        let l1 = LabeledSpan::underline(self.loc1.span);
        let l2 = LabeledSpan::underline(self.loc2.span);
        Some(Box::new(vec![l1, l2].into_iter()))
    }
}

/// Error raised for duplicate context declarations
#[derive(Debug, Clone, Error, Eq, PartialEq)]
#[error("duplicate context declaration. Action may have at most one context declaration")]
pub struct DuplicateContext {
    loc1: Loc,
    loc2: Loc,
}

impl Diagnostic for DuplicateContext {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        let l1 = LabeledSpan::underline(self.loc1.span);
        let l2 = LabeledSpan::underline(self.loc2.span);
        Some(Box::new(vec![l1, l2].into_iter()))
    }
}

/// Error raised when there are duplicate `principal` or `resource` declarations
#[derive(Debug, Clone, Error, PartialEq, Eq)]
#[error("duplicate `{kind}` declaration. Action may have at most one {kind} declaration")]
pub struct DuplicatePrincipalOrResource {
    kind: PR,
    loc1: Loc,
    loc2: Loc,
}

impl DuplicatePrincipalOrResource {
    #[cfg(test)]
    pub(crate) fn kind(&self) -> PR {
        self.kind
    }
}

impl Diagnostic for DuplicatePrincipalOrResource {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        let l1 = LabeledSpan::underline(self.loc1.span);
        let l2 = LabeledSpan::underline(self.loc2.span);
        Some(Box::new(vec![l1, l2].into_iter()))
    }
}

/// Error raised when there are duplicate namespace IDs
#[derive(Debug, Clone, Error, PartialEq, Eq)]
#[error("Duplicate namespace IDs: `{namespace_id}`")]
pub struct DuplicateNameSpaces {
    namespace_id: SmolStr,
    loc1: Option<Loc>,
    loc2: Option<Loc>,
}

impl DuplicateNameSpaces {
    pub fn namespace_id(&'_ self) -> impl AsRef<str> + '_ {
        self.namespace_id.as_ref()
    }
}

impl Diagnostic for DuplicateNameSpaces {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        let mut v = vec![];

        if let Some(l1) = self.loc1.as_ref() {
            v.push(LabeledSpan::underline(l1.span));
        }

        if let Some(l2) = self.loc2.as_ref() {
            v.push(LabeledSpan::underline(l2.span));
        }

        Some(Box::new(v.into_iter()))
    }
}
/// Error raised when a type is used without being defined
#[derive(Debug, Clone, Error, PartialEq, Eq)]
#[error("Unknown type name: `{}`", .0.node)]
pub struct UnknownTypeName(Node<SmolStr>);

impl UnknownTypeName {
    /// Get the name that was invalid
    pub fn name(&'_ self) -> impl AsRef<str> + '_ {
        self.0.node.as_ref()
    }
}

impl Diagnostic for UnknownTypeName {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        Some(Box::new(
            vec![LabeledSpan::underline(self.0.loc.span)].into_iter(),
        ))
    }
}

/// Use of a reserved namespace
#[derive(Debug, Clone, Error, PartialEq, Eq)]
#[error("Use reserved namespace `__cedar`")]
pub struct UseReservedNamespace(Loc);

impl Diagnostic for UseReservedNamespace {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        Some(Box::new(
            vec![LabeledSpan::underline(self.0.span)].into_iter(),
        ))
    }
}

impl ToJsonSchemaError {
    /// Creates a duplicate keys error
    pub fn duplicate_keys(key: SmolStr, loc1: Loc, loc2: Loc) -> Self {
        Self::DuplicateKeys(DuplicateKeys { key, loc1, loc2 })
    }

    /// Creates a duplicate declarations error
    pub fn duplicate_decls(decl: SmolStr, loc1: Loc, loc2: Loc) -> Self {
        Self::DuplicateDeclarations(DuplicateDeclarations { decl, loc1, loc2 })
    }

    /// Creates a duplicate namespaces error
    pub fn duplicate_namespace(
        namespace_id: SmolStr,
        loc1: Option<Loc>,
        loc2: Option<Loc>,
    ) -> Self {
        Self::DuplicateNameSpaces(DuplicateNameSpaces {
            namespace_id,
            loc1,
            loc2,
        })
    }

    /// Creates a duplicate context error
    pub fn duplicate_context(loc1: Loc, loc2: Loc) -> Self {
        Self::DuplicateContext(DuplicateContext { loc1, loc2 })
    }

    /// Creates a duplicate principal error
    pub fn duplicate_principal(loc1: Loc, loc2: Loc) -> Self {
        Self::DuplicatePrincipalOrResource(DuplicatePrincipalOrResource {
            kind: PR::Principal,
            loc1,
            loc2,
        })
    }

    /// Creates a duplicate resource error
    pub fn duplicate_resource(loc1: Loc, loc2: Loc) -> Self {
        Self::DuplicatePrincipalOrResource(DuplicatePrincipalOrResource {
            kind: PR::Resource,
            loc1,
            loc2,
        })
    }

    /// Creates a no principal error
    pub fn no_principal(name: SmolStr, loc: Loc) -> Self {
        Self::NoPrincipalOrResource(NoPrincipalOrResource {
            kind: PR::Principal,
            name,
            loc,
        })
    }

    /// Creates a no resource error
    pub fn no_resource(name: SmolStr, loc: Loc) -> Self {
        Self::NoPrincipalOrResource(NoPrincipalOrResource {
            kind: PR::Resource,
            name,
            loc,
        })
    }

    /// Create an unknown type name error
    pub fn unknown_type_name(name: Node<SmolStr>) -> Self {
        Self::UnknownTypeName(UnknownTypeName(name))
    }

    /// Create a reserved namespace use error
    pub fn use_reserved_namespace(loc: Loc) -> Self {
        Self::UseReservedNamespace(UseReservedNamespace(loc))
    }
}

/// Error raised when an action does not define a `principal` or `resource`
#[derive(Debug, Clone, Error, PartialEq, Eq)]
#[error("missing `{kind}` declaration for `{name}`. Actions must define both a `principals` and `resources` field")]
pub struct NoPrincipalOrResource {
    kind: PR,
    name: SmolStr,
    loc: Loc,
}

impl NoPrincipalOrResource {
    /// Get the name of the action that raised this error
    pub fn name(&'_ self) -> impl AsRef<str> + '_ {
        self.name.as_ref()
    }
}

impl Diagnostic for NoPrincipalOrResource {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = LabeledSpan> + '_>> {
        Some(Box::new(
            vec![LabeledSpan::underline(self.loc.span)].into_iter(),
        ))
    }
}

/// Error subtypes for [`SchemaWarning`]
pub mod schema_warnings {
    use cedar_policy_core::parser::Loc;
    use miette::Diagnostic;
    use smol_str::SmolStr;
    use thiserror::Error;

    /// Warning when a builtin Cedar name is shadowed
    //
    // CAUTION: this type is publicly exported in `cedar-policy`.
    // Don't make fields `pub`, don't make breaking changes, and use caution
    // when adding public methods.
    #[derive(Debug, Clone, Error)]
    #[error("The name `{name}` shadows a builtin Cedar name. You'll have to refer to the builtin as `__cedar::{name}`.")]
    pub struct ShadowsBuiltinWarning {
        pub(crate) name: SmolStr,
        pub(crate) loc: Loc,
    }

    impl Diagnostic for ShadowsBuiltinWarning {
        fn labels(&self) -> Option<Box<dyn Iterator<Item = miette::LabeledSpan> + '_>> {
            Some(Box::new(std::iter::once(miette::LabeledSpan::underline(
                self.loc.span,
            ))))
        }

        fn severity(&self) -> Option<miette::Severity> {
            Some(miette::Severity::Warning)
        }
    }

    /// Warning when an entity name is shadowed by a common type name
    //
    // CAUTION: this type is publicly exported in `cedar-policy`.
    // Don't make fields `pub`, don't make breaking changes, and use caution
    // when adding public methods.
    #[derive(Debug, Clone, Error)]
    #[error("The common type name {name} shadows an entity name")]
    pub struct ShadowsEntityWarning {
        pub(crate) name: SmolStr,
        pub(crate) entity_loc: Loc,
        pub(crate) common_loc: Loc,
    }

    impl Diagnostic for ShadowsEntityWarning {
        fn labels(&self) -> Option<Box<dyn Iterator<Item = miette::LabeledSpan> + '_>> {
            Some(Box::new(
                std::iter::once(&self.entity_loc)
                    .chain(std::iter::once(&self.common_loc))
                    .map(miette::LabeledSpan::underline),
            ))
        }

        fn severity(&self) -> Option<miette::Severity> {
            Some(miette::Severity::Warning)
        }
    }
}

/// Warning when constructing a schema
//
// CAUTION: this type is publicly exported in `cedar-policy`.
// Don't make fields `pub`, don't make breaking changes, and use caution
// when adding public methods.
#[derive(Debug, Clone, Error, Diagnostic)]
pub enum SchemaWarning {
    /// Warning when a declaration shadows a builtin type
    #[error(transparent)]
    #[diagnostic(transparent)]
    ShadowsBuiltin(#[from] schema_warnings::ShadowsBuiltinWarning),
    /// Warning when a declaration shadows an entity type
    #[error(transparent)]
    #[diagnostic(transparent)]
    ShadowsEntity(#[from] schema_warnings::ShadowsEntityWarning),
}
